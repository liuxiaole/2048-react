{"version":3,"sources":["HeaderBox.js","Tile.js","GameBoard.js","GameOver.js","Game.js","index.js"],"names":["ScoreBox","nextProps","this","props","score","children","label","className","Component","HeaderBox","bestScore","additionScores","map","i","key","onAnimationEnd","e","onAdditionScoreAnimationEnd","onClick","onNewGame","Tile","cell","col","row","classMap","tile","number","newGenerated","newMerged","classNames","Object","keys","filter","cls","join","y","style","transform","TileContainer","cells","reduce","tiles","j","push","mergedItem","sort","a","b","uuid","getTiles","GridContainer","nextSize","size","Array","fill","_","getGrids","GameBoard","href","GameOver","MOVE_DIR","up","down","left","right","tileUUID","Game","state","getInitialState","newTile","handleKeyPress","bind","window","addEventListener","removeEventListener","ev","gameStarted","match","toLowerCase","move","preventDefault","localStorage","getItem","fn","forEach","setState","emptyCells","eachCell","length","index","Math","floor","random","movable","bottomCell","rightCell","ms","Promise","resolve","setTimeout","dir","isMoving","dirOffset","hasMovingTile","nextCol","nextRow","nextCell","nextState","Date","now","sleep","then","checkGameStatus","isMovable","setItem","handleAdditionScoreAnimationEnd","startNewGame","onSwipe","scoreItem","slice","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9f971970.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './HeaderBox.css';\n\nclass ScoreBox extends Component {\n  shouldComponentUpdate (nextProps) {\n    return this.props.score !== nextProps.score || this.props.children !== nextProps.children;\n  }\n\n  render () {\n    let { label, score, children } = this.props;\n    return (\n      <div className=\"score-box\">\n        <div className=\"score-label\">{label}</div>\n        <div className=\"score-content\">{score}</div>\n        {children}\n      </div>\n    );\n  }\n}\n\nexport default class HeaderBox extends Component {\n  shouldComponentUpdate ({score, bestScore, additionScores}) {\n    let props = this.props;\n    return props.score !== score ||\n      props.bestScore !== bestScore ||\n      props.additionScores !== additionScores;\n  }\n\n  render () {\n    let props = this.props;\n    return (\n      <div className=\"header-box\">\n        <h1 className=\"title\">2048</h1>\n        <ScoreBox score={props.score} label=\"SCORE\">\n        {\n          props.additionScores.map((score, i) =>\n            <div className=\"addition-score\" key={score.key}\n              onAnimationEnd={(e) => props.onAdditionScoreAnimationEnd(e, score, i)}\n            >+{score.score}</div>\n          )\n        }\n        </ScoreBox>\n        <ScoreBox score={props.bestScore} label=\"BEST\" />\n        <div className=\"desc-txt\">\n          <span className=\"bold\">Play 2048 Game Online</span><br/>\n          Join the numbers and get to the <span className=\"bold\">2048 tile!</span>\n        </div>\n        <button className=\"new-game-btn\" onClick={props.onNewGame}>New Game</button>\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport './Tile.css';\n\nconst TILE_WIDTH = 100;\nconst TILE_GAP = 10;\n\nexport default class Tile extends Component {\n  render () {\n    let {cell, col, row} = this.props;\n    let classMap = {\n      tile: true,\n      [`tile-${cell.number}`]: true,\n      'tile-new': cell.newGenerated,\n      'tile-merged': !!cell.newMerged\n    };\n    let classNames = Object.keys(classMap).filter(cls => !!classMap[cls]).join(' ');\n    let x = col * ( TILE_WIDTH + TILE_GAP) + 'px';\n    let y = row * ( TILE_WIDTH + TILE_GAP) + 'px';\n    let style = {transform: `translate3d(${x}, ${y}, 0)`};\n    return (\n      <div className={classNames} style={style}>\n        <div className=\"tile-inner\">{cell.number}</div>\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport HeaderBox from './HeaderBox';\nimport Tile from './Tile';\nimport './GameBoard.css';\n\nclass TileContainer extends Component {\n  getTiles () {\n    return this.props.cells.reduce((tiles, row, i) =>\n      row.reduce((tiles, cell, j) => {\n        if (cell) {\n          tiles.push({cell, row: i, col: j});\n          if (cell.mergedItem) {\n            tiles.push({cell: cell.mergedItem, row: i, col: j});\n          }\n        }\n        return tiles;\n      }, tiles)\n    , [])\n    .sort((a, b) => a.cell.uuid - b.cell.uuid)\n    .map(tile => <Tile key={'tile-'+tile.cell.uuid} cell={tile.cell} col={tile.col} row={tile.row}></Tile>);\n  }\n\n  render () {\n    return (\n      <div className=\"tile-container\">{this.getTiles()}</div>\n    );\n  }\n}\n\nclass GridContainer extends Component {\n  shouldComponentUpdate ({nextSize}) {\n    let { size } = this.props;\n    return size !== nextSize;\n  }\n\n  getGrids () {\n    let { size } = this.props;\n    let row = i =>\n      new Array(size).fill().map((_, j) =>\n        <div className=\"grid-cell\" key={`grid-cell-${i * size + j}`}></div>\n      );\n    return new Array(size).fill().map((_, i) => row(i));\n  }\n\n  render () {\n    return (\n      <div className=\"grid-container\">{this.getGrids()}</div>\n    );\n  }\n}\n\nexport default function GameBoard (props) {\n  return (\n    <div className=\"game-board\">\n      <HeaderBox {...props}/>\n      <div className=\"game-box\">\n        <GridContainer size={props.size}/>\n        <TileContainer cells={props.cells}/>\n        {props.children}\n      </div>\n      <a href=\"https://github.com/liuxiaole/2048-react\" className=\"view-score-link\">view source on github</a>\n    </div>\n  );\n}\n","import React from 'react';\nimport './GameOver.css';\n\nexport default function GameOver ({onNewGame}) {\n  return <div className=\"game-over\">\n    <h1 className=\"title\">Game Over!</h1>\n    <button onClick={onNewGame}>Try Again</button>\n  </div>;\n}\n","import React, { Component } from 'react';\nimport GameBoard from './GameBoard';\nimport GameOver from './GameOver';\nimport Promise from 'promise';\n\nconst MOVE_DIR = {\n  up: [0, -1],\n  down: [0, 1],\n  left: [-1, 0],\n  right: [1, 0]\n};\n\nlet tileUUID = 0;\n\nexport default class Game extends Component {\n  constructor (props) {\n    super(props);\n    this.state = this.getInitialState();\n  }\n\n  componentDidMount () {\n    this.newTile();\n    this.newTile();\n    this.handleKeyPress = this.handleKeyPress.bind(this);\n    window.addEventListener('keydown', this.handleKeyPress);\n  }\n\n  componentWillUnmount () {\n    window.removeEventListener('keydown', this.handleKeyPress);\n  }\n\n  handleKeyPress (ev) {\n    let { key } = ev;\n\n    if (!this.state.gameStarted) return;\n    let match = key.toLowerCase().match(/arrow(up|right|down|left)/);\n    if (match) {\n      this.move(match[1]);\n      ev.preventDefault();\n    }\n  }\n\n  getInitialState () {\n    let size = this.props.size || 4;\n    let cells = [];\n    for (let i = 0; i < size; i++) {\n      let row = cells[i] = [];\n      for (let j = 0; j < size; j++) {\n        row[j] = null;\n      }\n    }\n    return {\n      size, cells,\n      gameStarted: true,\n      additionScores: [],\n      score: 0,\n      bestScore: +localStorage.getItem('bestScore')\n    };\n  }\n\n  eachCell (state, fn) {\n    return state.cells.forEach((row, i) =>\n        row.forEach((cell, j) => fn(cell, i, j))\n      );\n  }\n\n  newTile () {\n    this.setState(state => {\n      let cells = this.state.cells;\n      let emptyCells = [];\n      // get emptyCells and merge wait-to-merge items\n      this.eachCell(state, (cell, i, j) => {\n        if(!cell) {\n          emptyCells.push([i, j]);\n        } else if(cell.mergedItem) {\n          // do merge operation\n          cell.number += cell.mergedItem.number;\n          cell.newMerged = true; // set newMerged flag for animation\n        }\n      });\n      if (emptyCells.length) {\n        let index = Math.floor(Math.random() * emptyCells.length);\n        let [row, cell] = emptyCells[index];\n        cells[row][cell] = {\n          number: Math.random() > 0.8 ? 4 : 2,\n          newGenerated: true,\n          newMerged: false,\n          mergedItem: null,\n          uuid: tileUUID++\n        };\n      }\n      return {cells};\n    });\n  }\n\n  isMovable () {\n    let movable = false;\n    let cells = this.state.cells;\n    let size = this.state.size;\n    // check each cell,\n    // if there is any empty cell, sets movable to true\n    // if there are any adjacent cells which has the same number, sets movable to true\n    this.eachCell(this.state, (cell, i, j) => {\n      if (movable) return; // break;\n      if (!cell) {\n        movable = true;\n        return;\n      }\n      if (i < size - 1) {\n        let bottomCell = cells[i+1][j];\n        if (bottomCell && bottomCell.number === cell.number) {\n          movable = true;\n          return;\n        }\n      }\n      if (j < size - 1) {\n        let rightCell = cells[i][j+1];\n        if (rightCell && rightCell.number === cell.number) {\n          movable = true;\n          return;\n        }\n      }\n    });\n\n    return movable;\n  }\n\n  sleep (ms) {\n    return new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n  }\n\n  move (dir) {\n    if (this.isMoving) return;\n    let size = this.state.size;\n    let cells = this.state.cells;\n    let dirOffset = MOVE_DIR[dir];\n    let hasMovingTile = false;\n    let score = 0;\n\n    for (let i=0; i<size; i++) {\n      for (let j=0; j<size; j++) {\n        let row = i, col = j;\n        if (dir === 'right') {\n          // reverse col to get right-to-left iteration\n          col = size - j - 1;\n        }\n        if (dir === 'down') {\n          // reverse row to get bottom-to-top iteration\n          row = size - i - 1;\n        }\n\n        // map <i, j> to <row, col> according direction `dir`\n        let cell = cells[row][col];\n        if (!cell) continue; // current cell is empty\n\n        // reset tags\n        cell.newGenerated = false;\n        cell.newMerged = false;\n        cell.mergedItem = null;\n\n        // detect next cell in the direction of `dir`\n        // firstly, get the next coordinate\n        let nextCol = col + dirOffset[0];\n        let nextRow = row + dirOffset[1];\n        let nextCell;\n\n        // ensure that we're still in game board\n        while (nextCol >= 0 && nextCol < size && nextRow >=0 && nextRow < size) {\n          nextCell = cells[nextRow][nextCol];\n          if (nextCell) {\n            // found a non-empty cell in the dir direction, just break\n            break;\n          }\n          // next cell is empty, so walk forward the direction\n          nextCol += dirOffset[0];\n          nextRow += dirOffset[1];\n        }\n\n        if (nextCell && !nextCell.mergedItem && nextCell.number === cell.number) {\n          // get the same number cell, and the cell is not new merged one\n          // store the merged item, in the later, we'll do merge operation\n          // this is for better animation effect reason\n          cell.mergedItem = nextCell;\n          cells[nextRow][nextCol] = cell;\n          cells[row][col] = null;\n          hasMovingTile = true;\n          score += nextCell.number + cell.number; // calculate score\n        } else {\n          // step back, put the cell next to nextCell\n          nextCol -= dirOffset[0];\n          nextRow -= dirOffset[1];\n          // if next cell is not the current cell\n          if (nextCol !== col || nextRow !== row) {\n            cells[nextRow][nextCol] = cell;\n            cells[row][col] = null;\n            hasMovingTile = true;\n          }\n        }\n      }\n    }\n\n    if (hasMovingTile) {\n      this.isMoving = true;\n\n      this.setState(state => {\n        let nextState = {\n          cells,\n          score: state.score + score\n        };\n        if (score) {\n          // store the scores in array\n          // this is for better animation effect, additionScores is a queue\n          // when get score, enqueue score item, when animation end (there is an '+score' rasing up)\n          // dequeue the score item, key is for react list rendering\n          nextState.additionScores = [...state.additionScores, {score, key: 'score' + Date.now()}];\n        }\n        return nextState;\n      });\n\n      // sleep 80ms for move animation\n      this.sleep(80)\n        .then(() => {\n          this.newTile();\n          this.checkGameStatus();\n          this.isMoving = false;\n        });\n    }\n  }\n\n  checkGameStatus () {\n    let movable = this.isMovable();\n    if (!movable) {\n      // game over\n      let bestScore = this.state.bestScore;\n      if (bestScore < this.state.score) {\n        bestScore = this.state.score;\n        localStorage.setItem('bestScore', bestScore);\n      }\n      this.setState({gameStarted: false, bestScore});\n    }\n  }\n\n  render () {\n    return (\n      <div>\n        <GameBoard\n          {...this.state}\n          onAdditionScoreAnimationEnd={this.handleAdditionScoreAnimationEnd.bind(this)}\n          onNewGame={this.startNewGame.bind(this)}\n          onSwipe={this.move.bind(this)}\n        >\n          {!this.state.gameStarted &&\n            <GameOver onNewGame={this.startNewGame.bind(this)}></GameOver>\n          }\n        </GameBoard>\n      </div>\n    );\n  }\n\n  handleAdditionScoreAnimationEnd (ev, scoreItem, index) {\n    this.setState(state => {\n      let additionScores = state.additionScores;\n      // when score item is `raised up`, dequeue score item from additionScores\n      return {additionScores: [...additionScores.slice(0, index), ...additionScores.slice(index+1)]};\n    });\n  }\n\n  startNewGame () {\n    setTimeout(() => {\n      tileUUID = 0;\n      this.setState(this.getInitialState());\n      this.newTile();\n      this.newTile();\n    }, 0);\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Game from './Game';\nimport './index.css';\n\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}